# üåû Project Theme 4: Urban Solar Energy Mapping (The Master Plan)

## 1. Project Structure (Do This First)

Create a folder named `Solar_Project` on your Desktop. Inside, create exactly these subfolders:

```
/Solar_Project
    /scripts
        0_slice_images.py          # Prepares big images for AI
        1_check_viability.py       # (Student 3) Night Light Filter
        2_train_model.py           # (Student 1) The AI Brain
        3_inference_solar.py       # (Student 4/5) Building Detection + Energy Math
        4_classify_roofs.py        # (Student 2) Roof Type Analysis
    /data
        /training_raw              # Download "Inria Aerial Dataset" here
            /images
            /gt                    # Ground Truth (masks)
        /training_sliced           # (Generated by Script 0)
            /images
            /masks
        /project_area              # YOUR CITY DATA GOES HERE
            my_city.tif            # High-Res Satellite Image
            my_city_dsm.tif        # Digital Surface Model (Height)
            viirs_nightlight.tif   # Night Light Data
    /models
        solar_unet.pth             # (Generated by Script 2)
    /output
        solar_map_final.shp        # THE FINAL DELIVERABLE
```

## 2. The Data (Where to Download)

**Do not skip this. The code needs fuel.**

### Training Data (for the AI):

- **Dataset**: Inria Aerial Image Labeling Dataset (Registration required, free).
- **Action**: Download the "Training Set". Put 5 images in `/data/training_raw/images` and their corresponding masks in `/data/training_raw/gt`. (You don't need all 180GB for a student project; 10-20 images is enough to demonstrate).

### Project Area (Your City):

- **Satellite Image**: Use SASPlanet to export a GeoTIFF of your campus/neighborhood. Put in `/data/project_area/`.
- **DSM (Height)**: Download from JAXA ALOS World 3D or OpenTopography.
- **Night Lights**: Download VIIRS VNP46A1 from NASA Earthdata.

## 3. The Code (Copy & Paste)

### Script 0: The Slicer (Pre-processing)

**Problem**: Satellite images are 5000x5000 pixels. The AI only understands 512x512.  
**Solution**: This script chops them up.

```python
# scripts/0_slice_images.py
import os
from patchify import patchify
import cv2
import numpy as np

# CONFIG
SOURCE_IMG_DIR = '../data/training_raw/images/'
SOURCE_MASK_DIR = '../data/training_raw/gt/'
OUT_IMG_DIR = '../data/training_sliced/images/'
OUT_MASK_DIR = '../data/training_sliced/masks/'
PATCH_SIZE = 512

def slice_data():
    if not os.path.exists(OUT_IMG_DIR): os.makedirs(OUT_IMG_DIR)
    if not os.path.exists(OUT_MASK_DIR): os.makedirs(OUT_MASK_DIR)

    images = os.listdir(SOURCE_IMG_DIR)
    
    for img_name in images:
        if not img_name.endswith('.tif'): continue
        
        # Load Image & Mask
        img = cv2.imread(SOURCE_IMG_DIR + img_name)
        mask = cv2.imread(SOURCE_MASK_DIR + img_name, 0) # Grayscale
        
        # Patchify (Slice into squares)
        # Note: We drop the last chunk if it doesn't fit perfectly
        patches_img = patchify(img, (PATCH_SIZE, PATCH_SIZE, 3), step=PATCH_SIZE)
        patches_mask = patchify(mask, (PATCH_SIZE, PATCH_SIZE), step=PATCH_SIZE)
        
        for i in range(patches_img.shape[0]):
            for j in range(patches_img.shape[1]):
                
                single_patch_img = patches_img[i, j, 0]
                single_patch_mask = patches_mask[i, j]
                
                # Save only if the mask has buildings (Optimization)
                # if np.sum(single_patch_mask) > 0: 
                cv2.imwrite(f'{OUT_IMG_DIR}{img_name}_{i}_{j}.png', single_patch_img)
                cv2.imwrite(f'{OUT_MASK_DIR}{img_name}_{i}_{j}.png', single_patch_mask)

    print("‚úÖ Slicing Complete! Images ready for training.")

if __name__ == "__main__":
    slice_data()
```

### Script 1: The Viability Check (Student 3)

**Goal**: Check Night Lights to confirm the area is urban.

```python
# scripts/1_check_viability.py
import rasterio
import numpy as np

VIIRS_PATH = '../data/project_area/viirs_nightlight.tif'
THRESHOLD = 5.0 # nW/cm2/sr

def check_viability():
    try:
        with rasterio.open(VIIRS_PATH) as src:
            data = src.read(1)
            # Filter negatives (sensor noise)
            data = np.maximum(data, 0)
            avg_radiance = np.mean(data)
            
            print(f"üìä Average Night Light Radiance: {avg_radiance:.2f}")
            
            if avg_radiance > THRESHOLD:
                print("‚úÖ Area is URBAN. Proceeding with High-Res Analysis.")
                return True
            else:
                print("‚ùå Area is RURAL. Solar ROI too low. Aborting.")
                return False
    except FileNotFoundError:
        print("‚ö†Ô∏è No VIIRS file found. Skipping check (Assumed Urban).")
        return True

if __name__ == "__main__":
    check_viability()
```

### Script 2: The Training (Student 1)

**Goal**: Teach the U-Net model what a "building" looks like.

```python
# scripts/2_train_model.py
import os
import torch
import cv2
import numpy as np
import segmentation_models_pytorch as smp
from torch.utils.data import Dataset, DataLoader

# CONFIG
TRAIN_IMG_DIR = '../data/training_sliced/images/'
TRAIN_MASK_DIR = '../data/training_sliced/masks/'
MODEL_PATH = '../models/solar_unet.pth'
EPOCHS = 5

class BuildingDataset(Dataset):
    def __init__(self, img_dir, mask_dir):
        self.images = os.listdir(img_dir)
        self.img_dir = img_dir
        self.mask_dir = mask_dir
    
    def __len__(self): return len(self.images)
    
    def __getitem__(self, i):
        img_name = self.images[i]
        
        # Load
        img = cv2.imread(self.img_dir + img_name)
        img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
        mask = cv2.imread(self.mask_dir + img_name, 0)
        
        # Norm & Tensor
        img = img.transpose(2,0,1).astype('float32') / 255.0
        mask = np.expand_dims(mask, 0).astype('float32') / 255.0 # (1, H, W)
        
        return torch.from_numpy(img), torch.from_numpy(mask)

def train():
    dataset = BuildingDataset(TRAIN_IMG_DIR, TRAIN_MASK_DIR)
    loader = DataLoader(dataset, batch_size=8, shuffle=True)
    
    model = smp.Unet(encoder_name="resnet18", encoder_weights="imagenet", in_channels=3, classes=1)
    loss_fn = smp.losses.DiceLoss(mode='binary')
    optimizer = torch.optim.Adam(model.parameters(), lr=0.0001)
    
    print("üöÄ Starting Training...")
    model.train()
    
    for epoch in range(EPOCHS):
        total_loss = 0
        for imgs, masks in loader:
            optimizer.zero_grad()
            output = model(imgs)
            loss = loss_fn(output, masks)
            loss.backward()
            optimizer.step()
            total_loss += loss.item()
        print(f"Epoch {epoch+1}/{EPOCHS} | Loss: {total_loss/len(loader):.4f}")
        
    torch.save(model.state_dict(), MODEL_PATH)
    print("‚úÖ Model Saved!")

if __name__ == "__main__":
    train()
```

### Script 3: Inference & Physics (Students 1, 4, 5)

**Goal**: Detect buildings, vectorize them, and calculate Solar Potential.

```python
# scripts/3_inference_solar.py
import torch
import segmentation_models_pytorch as smp
import rasterio
from rasterio.windows import Window
from rasterio.features import shapes
from shapely.geometry import shape
import geopandas as gpd
import numpy as np

# CONFIG
MODEL_PATH = '../models/solar_unet.pth'
BIG_IMG = '../data/project_area/my_city.tif'
OUTPUT_SHP = '../output/solar_map_final.shp'

# SOLAR CONSTANTS
IRRADIANCE = 1800  # kWh/m2
EFFICIENCY = 0.20  # 20%
PR = 0.75          # Performance Ratio
COST_UNIT = 8.0    # INR/kWh

def main():
    # 1. Load Model
    model = smp.Unet(encoder_name="resnet18", classes=1)
    model.load_state_dict(torch.load(MODEL_PATH))
    model.eval()
    
    polygons = []
    
    print("üõ∞Ô∏è  Processing Satellite Image...")
    with rasterio.open(BIG_IMG) as src:
        H, W = src.height, src.width
        
        # Sliding Window Loop
        for row in range(0, H, 512):
            for col in range(0, W, 512):
                window = Window(col, row, 512, 512)
                chip = src.read(window=window, infinite=False)
                
                # Padding if chip is small (edge of map)
                if chip.shape[1] < 512 or chip.shape[2] < 512: continue

                # Predict
                tensor = torch.from_numpy(chip[:3]/255.0).float().unsqueeze(0)
                with torch.no_grad():
                    mask = model(tensor).sigmoid().numpy()[0,0]
                
                binary = (mask > 0.5).astype(np.uint8)
                
                # Vectorize
                transform = src.window_transform(window)
                for geom, val in shapes(binary, transform=transform):
                    if val == 1:
                        polygons.append(shape(geom))
    
    # 2. Create DataFrame
    gdf = gpd.GeoDataFrame({'geometry': polygons}, crs=src.crs)
    
    # 3. Solar Math (Student 4)
    gdf['area_m2'] = gdf.area
    gdf = gdf[gdf['area_m2'] > 20] # Filter noise
    
    # Default assumptions (refined in Script 4)
    gdf['usable_area'] = gdf['area_m2'] * 0.7 
    gdf['energy_kwh'] = gdf['usable_area'] * IRRADIANCE * EFFICIENCY * PR
    gdf['savings_inr'] = gdf['energy_kwh'] * COST_UNIT
    
    gdf.to_file(OUTPUT_SHP)
    print(f"‚úÖ Map Generated! Found {len(gdf)} buildings.")

if __name__ == "__main__":
    main()
```

### Script 4: Roof Classification (Student 2)

**Goal**: Refine the map using DSM height data.

```python
# scripts/4_classify_roofs.py
import geopandas as gpd
import rasterio
from rasterio.mask import mask
import numpy as np

# CONFIG
SHP_PATH = '../output/solar_map_final.shp'
DSM_PATH = '../data/project_area/my_city_dsm.tif'

def classify():
    gdf = gpd.read_file(SHP_PATH)
    roof_types = []
    
    try:
        with rasterio.open(DSM_PATH) as src:
            # Reproject if needed
            if gdf.crs != src.crs:
                gdf = gdf.to_crs(src.crs)
                
            print("üìê Analyzing Roof Slopes...")
            for idx, row in gdf.iterrows():
                try:
                    out_img, _ = mask(src, [row['geometry']], crop=True)
                    valid_pixels = out_img[out_img > -100] # Ignore NoData
                    
                    if len(valid_pixels) == 0:
                        roof_types.append("Unknown")
                        continue
                        
                    # Logic: Standard Deviation of Height
                    std_dev = np.std(valid_pixels)
                    
                    if std_dev < 1.0: roof_types.append("Flat")
                    else: roof_types.append("Gable")
                    
                except: roof_types.append("Error")
                
        gdf['roof_type'] = roof_types
        
        # Update Solar Math based on Type
        # Flat = 70% usable, Gable = 50% usable (one side)
        gdf['usable_area'] = np.where(gdf['roof_type'] == 'Flat',
                                      gdf['area_m2'] * 0.7,
                                      gdf['area_m2'] * 0.5)
                                      
        # Recalculate Energy
        IRRADIANCE = 1800; EFFICIENCY = 0.20; PR = 0.75
        gdf['energy_kwh'] = gdf['usable_area'] * IRRADIANCE * EFFICIENCY * PR
        
        gdf.to_file(SHP_PATH)
        print("‚úÖ Roofs Classified! Map Updated.")
        
    except FileNotFoundError:
        print("‚ö†Ô∏è DSM not found. Skipping classification (Keeping defaults).")

if __name__ == "__main__":
    classify()
```

## 4. Step-by-Step Execution Guide

1. **Setup**: Install Python and libraries (`pip install rasterio geopandas torch ...`).

2. **Download**: Get Inria dataset (Script 0 fails without it) and your City Image.

3. **Step 1**: Run `python 0_slice_images.py`. Wait for it to create small chips.

4. **Step 2**: Run `python 2_train_model.py`. This will take 1-2 hours on a laptop CPU (or 10 mins on GPU). It creates `solar_unet.pth`.

5. **Step 3**: Run `python 1_check_viability.py` to confirm your city has night lights.

6. **Step 4**: Run `python 3_inference_solar.py`. This reads your city map and creates the Shapefile.

7. **Step 5**: Run `python 4_classify_roofs.py` to add "Flat vs Gable" logic.

8. **Final Step**: Open `output/solar_map_final.shp` in QGIS.
   - Right Click Layer ‚Üí Properties ‚Üí Symbology ‚Üí Graduated
   - Column: `energy_kwh`
   - Color Ramp: Red (High Energy) to Blue (Low)
